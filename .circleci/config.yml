version: 2.1
# ============================================================
# CircleCI CI/CD Pipeline Configuration for Yotta Aksara Energi
# ------------------------------------------------------------
# Executor:
#   - Menggunakan Docker image cimg/base:stable sebagai lingkungan build.
#
# Jobs:
#   - build-and-test:
#       - Checkout kode.
#       - Setup Docker Compose & remote Docker.
#       - Generate file .env untuk environment build.
#       - Build image Docker aplikasi Laravel.
#       - Jalankan docker compose untuk semua service (app, db, dll).
#       - Setup Laravel (config clear, cache clear, migrate, seed).
#       - Cleanup container & image setelah selesai.
#       - Simpan versi image ke workspace.
#   - push-to-dockerhub:
#       - Login ke DockerHub.
#       - Push image hasil build ke DockerHub dengan tag versi dan latest.
#   - deploy-staging:
#       - SSH ke server staging.
#       - Generate .env jika belum ada atau ada key yang kosong.
#       - Pull image terbaru dari DockerHub.
#       - Jalankan docker compose up -d --build.
#       - Jalankan migrate & seed di staging.
#   - deploy-production:
#       - SSH ke server production.
#       - Generate .env jika belum ada atau ada key yang kosong.
#       - Pull image terbaru dari DockerHub.
#       - Jalankan docker compose up -d --build.
#       - Jalankan migrate di production.
#
# Workflows:
#   - build-and-test → approval → push-to-dockerhub → approval → deploy-staging/production (dengan approval manual).
#   - Pipeline hanya berjalan pada branch ci-cd/test.
# ============================================================

executors:
  docker-executor:
    docker:
      - image: cimg/base:stable

# ...existing code...

executors:
  docker-executor:
    docker:
      - image: cimg/base:stable

jobs:
# ======================= BUILD AND TEST ========================
  build-and-test:
    executor: docker-executor
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Generate local .env for testing
          command: |
            echo "APP_NAME=${APP_NAME}" >> .env
            echo "APP_ENV=${APP_ENV}" >> .env
            echo "APP_KEY=${APP_KEY}" >> .env
            echo "APP_DEBUG=${APP_DEBUG}" >> .env
            echo "APP_URL=${APP_URL}" >> .env
            echo "DB_CONNECTION=${DB_CONNECTION}" >> .env
            echo "DB_HOST=${DB_HOST}" >> .env
            echo "DB_PORT=3306" >> .env
            echo "DB_DATABASE=${DB_DATABASE}" >> .env
            echo "DB_USERNAME=${DB_USERNAME}" >> .env
            echo "DB_PASSWORD=${DB_PASSWORD}" >> .env
            echo "CACHE_DRIVER=${CACHE_STORE}" >> .env
            echo "SESSION_DRIVER=${SESSION_DRIVER}" >> .env
            echo "QUEUE_CONNECTION=${QUEUE_CONNECTION}" >> .env
            echo "APP_TIMEZONE=${APP_TIMEZONE}" >> .env
      - run:
          name: Build Docker Image
          command: |
            VERSION="v1"
            echo "VERSION=$VERSION" > version.env
            docker build -t yotta-aksara-energi:$VERSION .
      - run:
          name: Run Docker Compose
          command: docker compose up -d
      - run:
          name: Laravel Setup
          command: |
            docker exec yotta-dashboard php artisan config:clear
            docker exec yotta-dashboard php artisan cache:clear
            docker exec yotta-dashboard php artisan migrate --force || { docker exec yotta-dashboard cat storage/logs/laravel.log; exit 1; }
            docker exec yotta-dashboard php artisan db:seed --force || { docker exec yotta-dashboard cat storage/logs/laravel.log; exit 1; }
      - run:
          name: Test Laravel Endpoint
          command: |
            echo "Testing /health endpoint..."
            for i in {1..5}; do
              RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8002/health)
              if [ "$RESPONSE" = "200" ]; then
                echo "✅ Endpoint /health is OK"
                break
              fi
              echo "Waiting for Laravel to be ready..."
              sleep 5
            done
            if [ "$RESPONSE" != "200" ]; then
              echo "❌ Endpoint /health did not respond 200"
              exit 1
            fi
      - run:
          name: Cleanup Docker
          command: docker compose down --remove-orphans && docker system prune -f
      - persist_to_workspace:
          root: .
          paths:
            - version.env

# ====================== PUSH TO DOCKERHUB ========================
  push-to-dockerhub:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - attach_workspace:
          at: .
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Docker Login
          command: echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
      - run:
          name: Push Image
          command: |
            VERSION=$(cut -d '=' -f2 version.env)
            docker tag yotta-aksara-energi:$VERSION $DOCKERHUB_REPO:$VERSION
            docker push $DOCKERHUB_REPO:$VERSION
            docker tag yotta-aksara-energi:$VERSION $DOCKERHUB_REPO:latest
            docker push $DOCKERHUB_REPO:latest

# ===================== DEPLOY TO STAGING SERVER ========================
  deploy-staging:
    docker:
      - image: cimg/base:stable
    steps:
      - add_ssh_keys
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Deploy to Staging
          command: |
            VERSION=$(cut -d '=' -f2 version.env)
            ssh -o StrictHostKeyChecking=no $STAGING_USER@$STAGING_HOST "
              cd $STAGING_PATH

              # Generate .env if not exists or missing keys
              REQUIRED_KEYS=(APP_NAME APP_ENV APP_KEY APP_DEBUG APP_URL DB_CONNECTION DB_DATABASE DB_HOST DB_USERNAME DB_PASSWORD CACHE_DRIVER SESSION_DRIVER QUEUE_CONNECTION APP_TIMEZONE)
              GENERATE_ENV=false

              if [ ! -f .env ]; then
                GENERATE_ENV=true
              else
                for key in \${REQUIRED_KEYS[@]}; do
                  if ! grep -q \"^\\$key=\" .env || grep -q \"^\\$key=\$\" .env; then
                    GENERATE_ENV=true
                    break
                  fi
                done
              fi

              if [ \"\$GENERATE_ENV\" = true ]; then
                echo \"APP_NAME=$APP_NAME\" > .env
                echo \"APP_ENV=$APP_ENV\" >> .env
                echo \"APP_KEY=$APP_KEY\" >> .env
                echo \"APP_DEBUG=$APP_DEBUG\" >> .env
                echo \"APP_URL=$APP_URL\" >> .env
                echo \"DB_CONNECTION=$DB_CONNECTION\" >> .env
                echo \"DB_HOST=$DB_HOST\" >> .env
                echo \"DB_PORT=3306\" >> .env
                echo \"DB_DATABASE=$DB_DATABASE\" >> .env
                echo \"DB_USERNAME=$DB_USERNAME\" >> .env
                echo \"DB_PASSWORD=$DB_PASSWORD\" >> .env
                echo \"CACHE_DRIVER=$CACHE_STORE\" >> .env
                echo \"SESSION_DRIVER=$SESSION_DRIVER\" >> .env
                echo \"QUEUE_CONNECTION=$QUEUE_CONNECTION\" >> .env
                echo \"APP_TIMEZONE=$APP_TIMEZONE\" >> .env
              fi

              docker pull $DOCKERHUB_REPO:$VERSION
              docker compose down --remove-orphans || true
              docker compose up -d --build
              docker exec yotta-dashboard php artisan migrate --force || { docker exec yotta-dashboard cat storage/logs/laravel.log; exit 1; }
              docker exec yotta-dashboard php artisan db:seed --force || { docker exec yotta-dashboard cat storage/logs/laravel.log; exit 1; }
            "

# ==================== DEPLOY TO PRODUCTION SERVER ========================
  deploy-production:
    docker:
      - image: cimg/base:stable
    steps:
      - add_ssh_keys
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Deploy to Production
          command: |
            VERSION=$(cut -d '=' -f2 version.env)
            ssh -o StrictHostKeyChecking=no $PROD_USER@$PROD_HOST "
              cd $PROD_PATH

              # Generate .env if not exists or missing keys
              REQUIRED_KEYS=(APP_NAME APP_ENV APP_KEY APP_DEBUG APP_URL DB_CONNECTION DB_DATABASE DB_HOST DB_USERNAME DB_PASSWORD CACHE_DRIVER SESSION_DRIVER QUEUE_CONNECTION APP_TIMEZONE)
              GENERATE_ENV=false

              if [ ! -f .env ]; then
                GENERATE_ENV=true
              else
                for key in \${REQUIRED_KEYS[@]}; do
                  if ! grep -q \"^\\$key=\" .env || grep -q \"^\\$key=\$\" .env; then
                    GENERATE_ENV=true
                    break
                  fi
                done
              fi

              if [ \"\$GENERATE_ENV\" = true ]; then
                echo \"APP_NAME=$APP_NAME\" > .env
                echo \"APP_ENV=production\" >> .env
                echo \"APP_KEY=$APP_KEY\" >> .env
                echo \"APP_DEBUG=false\" >> .env
                echo \"APP_URL=$APP_URL\" >> .env
                echo \"DB_CONNECTION=$DB_CONNECTION\" >> .env
                echo \"DB_HOST=$DB_HOST\" >> .env
                echo \"DB_PORT=3306\" >> .env
                echo \"DB_DATABASE=$DB_DATABASE\" >> .env
                echo \"DB_USERNAME=$DB_USERNAME\" >> .env
                echo \"DB_PASSWORD=$DB_PASSWORD\" >> .env
                echo \"CACHE_DRIVER=$CACHE_STORE\" >> .env
                echo \"SESSION_DRIVER=$SESSION_DRIVER\" >> .env
                echo \"QUEUE_CONNECTION=$QUEUE_CONNECTION\" >> .env
                echo \"APP_TIMEZONE=$APP_TIMEZONE\" >> .env
              fi

              docker pull $DOCKERHUB_REPO:$VERSION
              docker compose down --remove-orphans || true
              docker compose up -d --build
              docker exec yotta-dashboard php artisan migrate --force || { docker exec yotta-dashboard cat storage/logs/laravel.log; exit 1; }
            "

# ==================== CI/CD PIPELINE ========================
workflows:
  version: 2
  ci-cd:
    jobs:
      - build-and-test:
          context: [global, staging]
          filters:
            branches:
              only: ci-cd/test
      - hold-push:
          type: approval
          requires:
            - build-and-test
      - push-to-dockerhub:
          requires:
            - hold-push
          context: [global]
      - hold-staging:
          type: approval
          requires:
            - push-to-dockerhub
      - deploy-staging:
          requires:
            - hold-staging
          context: [global, staging]
      - hold-production:
          type: approval
          requires:
            - push-to-dockerhub
      - deploy-production:
          requires:
            - hold-production
          context: [global]
